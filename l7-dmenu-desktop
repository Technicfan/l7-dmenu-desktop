#!/bin/bash

cachedir="$HOME/.cache/l7-dmenu-desktop"
configdir="$HOME/.config/l7-dmenu-desktop"
lockfile="$cachedir/lock_desktop"
appcache="$cachedir/apps"
statusfile="$cachedir/changed"
aliasesfile="$configdir/aliases"
excludefile="$configdir/excludes"
configfile="$configdir/config"
lang=$(awk -F "_" '{print $1}' <<< "$LANG")
desktopdirs=(
    "/usr/share/applications"
    "/usr/local/share/applications"
    "$HOME/.local/share/applications"
    "/var/lib/flatpak/exports/share/applications"
    "$HOME/.local/flatpak/exports/share/applications"
)

# check if desktop file caching is already running to prevent cache curruption
checkrunning()
{
    [[ ! -e "$cachedir" ]] && mkdir "$cachedir"
    if [[ -f "$1" ]]
    then
        echo "Already running!" >&2
        exit 1
    fi
}

# only send notification when command available
notify()
{
    command -v "notify-send" && notify-send -a "l7-dmenu-desktop" "$1"
}

# list app names found in desktopdirs and build cache with details
get_apps()
{
    # get name of an app from its .desktop file and check if it should be displayed
    get_details()
    {
        [[ -f "$1" ]] && entry=$(sed -n '/\[Desktop Entry\]/,/^\[/p' "$1")
        if [[ -n $entry ]] && \
        ! grep -q "^NoDisplay=true" <<< "$entry" && \
        ! grep -q "^Hidden=true" <<< "$entry" && \
          grep -q "^Type=Application" <<< "$entry"
        then
            # try to find name in system language,
            # if not found use default one
            name=$(awk -F "=" '{print $2}' \
                   <(grep "^Name\[$2\]=" <<< "$entry" || grep "^Name=" <<< "$entry"))
            [[ -n "$name" ]] && echo "$name""; ""$1""; 1"
        fi
        [[ -z "$name" ]] && echo "hidden; ""$1""; 0"
    }
    # create or update the cache for one directory
    update_cache()
    {
        if [[ -d "$2" ]]
        then
            # init variables that are needed for both ways
            readarray -t files < <(find "$2" -type f,l -name "*.desktop" | sort -u)
            [[ -f "$1" ]] && readarray -t cached_files < <(awk -F "; " '{print $2}' "$1" | grep "$2" | sort -u)
            # check if cache need to be build completely
            if [[ -z "${cached_files[*]}" && -n "${files[*]}" ]]
            then
                #export -f get_details
                #parallel -j12 get_details ::: "${files[@]}" ::: "$3" >> "$1"
                for file in "${files[@]}"
                do
                    get_details "$file" "$3" >> "$1" &
                    pids+=($!)
                done
                for pid in "${pids[@]}"
                do
                    wait "$pid"
                done
                # create file to signify change
                touch "$4"
            # check if there were any changes after last cache time
            elif [[ "${cached_files[*]}" != "${files[*]}" ]]
            then
                notify "noob"
                readarray -t changes < <(diff <(printf '\n%s' "${cached_files[@]}") <(printf '\n%s' "${files[@]}"))
                # for every found change either add or remove the entry from cache
                for change in "${changes[@]}"
                do
                    if [[ "$change" = ">"* ]]
                    then
                        file=${change//> /}
                        get_details "$file" "$3" >> "$1"
                        name="$(grep "$file; 1$" "$1" | sed 's/;.*//g')"
                        # remove all numbered versions to prevent dulicate numbers
                        sed -i "s/^$name (\([0-9]*\)); /$name; /g" "$1"
                        # same file as above
                        ! [[ -f "$4" ]] && touch "$4"
                    elif [[ "$change" = "<"* ]]
                    then
                        file=${change//< /}
                        name="$(grep "$file; 1$" "$1" | sed 's/;.*//g; s/ (\([0-9]*\))$//g')"
                        sed -i "\|; $file; |d" "$1"
                        # also remove all numbered versions to prevent missing numbers
                        sed -i "s/^$name (\([0-9]*\)); /$name; /g" "$1"
                        # same file as above
                        ! [[ -f "$4" ]] && touch "$4"
                    fi
                    pids+=($!)
                done
                for pid in "${pids[@]}"
                do
                    wait "$pid"
                done
            fi
        fi
    }
    # create lock file
    touch "$3"
    # run the functions in parallel
    for desktopdir in $1
    do
        update_cache "$2" "$desktopdir" "$5" "$4" &
        pids+=($!)
    done
    for pid in "${pids[@]}"
    do
        wait "$pid"
    done
    # check for duplicates and number them to prevent missing entries if statusfile exists
    [[ -f "$4" ]] && awk -i inplace -F "; " '
    {
        count[$1]++
        if (count[$1] == 1 || $1 == "hidden") {
            print $0
        } else {
            print $1 " (" count[$1]-1 "); " $2 "; " $3
        }
    }
    ' "$2" && rm "$4"
    # print resulting app list
    grep "; 1$" "$2" | sed 's/;.*$//g'
    # remove lockfile
    rm "$3"
}

# list the alias names from config file
get_aliases()
{
    [[ -f "$1" ]] && grep "^alias .*=.*" "$1" | sed 's/alias //g; s/=.*$//g'
}

# excute the selected item
execute()
{
    # execute a desktop file by extracting infos manually,
    # because I didn't find a good solution to do this and it's fun;)
    # while dex is the best one I found it has some bugs which make it not work
    # with some apps on my system
    execute_desktop()
    {
        # get exec
        entry=$(sed -n '/\[Desktop Entry\]/,/^\[/p' "$1")
        command=$(grep "^Exec=" <<< "$entry" | sed "s/^Exec=//g; s/%. //g; s/%.$//g")
        # check if exec found
        if [[ -n "$command" ]]
        then
            # check if path specified
            if grep -q "^Path=.*" <<< "$entry"
            then
                path=$(grep "^Path=" <<< "$entry" | sed 's/^Path=//g')
                command="pushd '$path' && $command"
            fi
            # check if it should be run in terminal
            if grep -q "^Terminal=true" <<< "$entry"
            then
                command="$2 -e ${SHELL:-"/bin/sh"} -c \"$command\""
            fi
            # execute the resulting command
            printf '%b' "$command" | ${SHELL:-"/bin/sh"}
        # send error
        else
            notify "Invalid desktop file"
        fi
    }
    # check if input is in cache and if true execute it with custom function or dex
    run_app()
    {
        # check if input is in cache -> exists
        if [[ -f "$2" ]] && grep -q "^$1;" "$2"
        then
            # get and execute .desktop file
            file="$(grep "^$1;" "$2" | awk -F "; " '{print $2}')"
            execute_desktop "$file" "$3" &
            return
        else
            return 1
        fi
    }

    if [[ -n $1 ]]
    then
        # check if input is an alias and if run execute it
        if [[ -f "$3" ]] && grep -q "^alias $1=" "$4"
        then
            target=$(grep "^alias $1=" "$4" | sed "s/alias $1=//g")
            # check if it references a desktop entry
            if [[ "$target" = *"; desktop" ]]
            then
                run_app "${target//; desktop/}" "$3" "$5" "$7" || \
                                 notify "Invalid desktop alias"
                return
            else
                $target || notify "Invalid alias"
                return
            fi
        # try desktop file
        else
            run_app "$1" "$3" "$5" "$7" && return
        fi
        # prevent confirmation if addpath=1
        if [[ $6 = 1 ]]
        then
            for entry in $2
            do
                if [[ "$1" = "$entry" ]]
                then
                    $1 &
                    return
                fi
            done
        fi
        # check if specified to run as command
        if [[ $1 = $"~"* ]]
        then
            command="${1:1}"
        else
            command=$1
        fi
        # check if input is an available command, ask for confirmation and run it
        if command -v "$(awk '{print $1}' <<< "$command")"
        then
            if [[ $(printf "No\nYes" | \
                    eval "${menu//~prompt~/\'${7//~command~/\"$command\"}\'}") = "Yes" ]]
            then
                $command &
            fi
        # send error and restart the script
        else
            notify "Invalid command"
            $0 "$8" &
        fi
    fi
}

# remove excluded (excludefile) items from list
exclude()
{
    list="$2"
    if [[ -f "$1" ]]
    then
        while read -r exclude
        do
            list=$(sed "/^$exclude$/d" <<< "$list")
        done < "$1"
    fi
    echo "$list"
}

checkrunning "$lockfile"
# check the arguments
for arg in "$@"
do
    case $arg in
    # print help and exit
    -h|--help)
        printf '%s\n' "Use --dmenu=<menu> to change menu command" \
            "Use --clean to clear cache and rebuild it" \
            "When not using --dmenu= flag arguments are passed to regular dmenu"\
                "instead of your desired prompt write ~prompt~ without quotation marks"
        exit 0
        ;;
    # check if custom dmenu command given
    --dmenu=*)
        menu=${arg//--dmenu=/}
        ;;
    # remove files from cachedir?
    --clean)
        [[ -f "$lockfile" ]] && rm "$lockfile"
        [[ -f "$appcache" ]] && rm "$appcache"
        c=1
        ;;
    # notify the script that no menu command should be used?
    --benchmark)
        b=1
        ;;
    esac
done

# load variables from config file
[[ -f "$configfile" ]] && source "$configfile"
# load the list of programs according to the config
echo -ne "looking for changes..."
if [[ $hidedesktop != 1 ]]
then
    entries=$(get_apps "${desktopdirs[*]}" "$appcache" "$lockfile" "$statusfile" "$lang" 2>/dev/null)
fi
if [[ $addpath = 1 ]]
then
    if command -v "dmenu_path"
    then
        entries+=$(echo && dmenu_path)
    else
        notify "Install dmenu to add items from PATH"
    fi
fi
echo -ne "\r\033[K"
# print info about read and found .desktop files/apps
[[ $hidedesktop != 1 ]] && echo "Read $(wc -l < "$appcache") .desktop files," \
                                "found $(wc -l < <(grep "; 1$" "$appcache")) apps." &
# configure menu command to use if not already set with the existing info collected before
if [[ -z "$menu" && $b != 1 ]]
then
    if [[ $c = 1 ]]
    then
        menu="dmenu ${*//--clean/}"
    elif [[ "$*" != ".*-p .*" ]]
    then
        menu="dmenu $* -p ~prompt~"
    else
        menu="dmenu $*"
    fi
# don't need a menu command?
elif [[ $b = 1 ]]
then
    menu=""
fi
# print apps/programs in menu system and execute selection
selection=$(sed '/^$/d' <(get_aliases "$aliasesfile" & exclude "$excludefile" "$entries") | \
            sort -u | ${menu//~prompt~/${prompt1:-"Run:"}})
execute "$selection" "$entries" "$appcache" "$aliasesfile" \
        "${term:-"alacritty"}" "$addpath" "${prompt2:-"Run ~command~ with bash?"}" "$*"